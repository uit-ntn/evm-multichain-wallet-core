/**
 * Receipt Service
 * Business logic cho IPFS receipts (Pinata version)
 */

const axios = require("axios");
const FormData = require("form-data");
const fs = require("fs");
const path = require("path");
const PDFDocument = require("pdfkit");
const { logger } = require("../adapters/logger.adapter");
const Receipt = require("../models/receipt.model");

// L·∫•y token Pinata t·ª´ .env
const pinataJWT = process.env.PINATA_JWT;
if (!pinataJWT) throw new Error("Missing PINATA_JWT in environment");

/**
 * Upload file (PDF/JSON) l√™n IPFS th√¥ng qua Pinata
 */
const uploadToIPFS = async (filePath, fileName) => {
  try {
    const data = new FormData();
    data.append("file", fs.createReadStream(filePath));

    const res = await axios.post(
      "https://api.pinata.cloud/pinning/pinFileToIPFS",
      data,
      {
        maxBodyLength: Infinity,
        headers: {
          Authorization: `Bearer ${pinataJWT}`,
          ...data.getHeaders(),
        },
      }
    );

    const cid = res.data.IpfsHash;
    const url = `https://gateway.pinata.cloud/ipfs/${cid}`; // ‚úÖ kh√¥ng c·∫ßn /<fileName>

    logger.info("‚úÖ File uploaded to IPFS via Pinata", { cid, url });
    return { cid, url };
  } catch (error) {
    logger.error("‚ùå IPFS upload error (Pinata)", { error: error.message });
    throw error;
  } finally {
    // Xo√° file t·∫°m sau khi upload
    if (fs.existsSync(filePath)) fs.unlinkSync(filePath);
  }
};

/**
 * Sinh file PDF bi√™n lai giao d·ªãch
 */
const generateReceiptPDF = async (txHash, owner, meta) => {
  const tmpDir = path.join(__dirname, "../../uploads");
  if (!fs.existsSync(tmpDir)) fs.mkdirSync(tmpDir, { recursive: true });

  const pdfPath = path.join(tmpDir, `receipt_${txHash}.pdf`);
  const doc = new PDFDocument({ margin: 50, size: "A5" });
  const writeStream = fs.createWriteStream(pdfPath);
  doc.pipe(writeStream);

  // Header
  doc
    .fontSize(20)
    .font("Helvetica-Bold")
    .text("SAMPLE RECEIPT", { align: "center" })
    .moveDown(0.3);

  doc
    .fontSize(10)
    .font("Helvetica")
    .text("Blockchain Transaction Receipt", { align: "center" })
    .moveDown(0.5);

  doc
    .fontSize(8)
    .text("Generated by EVM Multichain Wallet", { align: "center" })
    .moveDown(1);

  // Separator line
  doc.moveTo(40, doc.y).lineTo(300, doc.y).strokeColor("#000").stroke();

  // Transaction info
  doc.moveDown(0.8);
  doc.fontSize(10).font("Helvetica-Bold").text("TRANSACTION DETAILS");
  doc.moveDown(0.5);
  doc.fontSize(9).font("Helvetica");
  doc.text(`Tx Hash: ${txHash}`, { width: 280 });
  doc.text(`Owner: ${owner}`);
  doc.text(`Date: ${new Date().toLocaleString()}`);
  doc.moveDown(0.3);

  // Metadata block
  doc.moveDown(0.8);
  doc.fontSize(10).font("Helvetica-Bold").text("TRADE DETAILS");
  doc.moveDown(0.3);
  doc.font("Helvetica");
  doc.text(`Pair: ${meta.pair || "N/A"}`);
  doc.text(`Amount In: ${meta.amountIn || "N/A"} ETH`);
  doc.text(`Amount Out: ${meta.amountOut || "N/A"} USDT`);
  doc.text(`Price: ${meta.price || "N/A"}`);
  doc.moveDown(0.8);

  // Dashed separator
  const y = doc.y;
  doc
    .moveTo(40, y)
    .lineTo(300, y)
    .dash(3, { space: 3 })
    .strokeColor("#555")
    .stroke()
    .undash();

  // Summary
  doc.moveDown(1);
  doc.fontSize(10).font("Helvetica-Bold").text("TOTAL SUMMARY");
  doc.font("Helvetica").fontSize(9);
  doc.text(`Final Amount: ${meta.amountOut || "N/A"} USDT`, { align: "left" });
  doc.text(`Network: Sepolia Testnet`, { align: "left" });
  doc.text(`Status: ‚úÖ Confirmed`, { align: "left" });

  // Signature line
  doc.moveDown(2);
  const signatureLineY = doc.y + 10;
  doc
    .moveTo(60, signatureLineY)
    .lineTo(200, signatureLineY)
    .strokeColor("#000")
    .stroke();
  doc.fontSize(9).text("Authorized Signature", 70, signatureLineY + 5);

  // Footer
  doc.moveDown(2);
  doc
    .fontSize(8)
    .fillColor("#555")
    .text("Thank you for using EVM Multichain Wallet", { align: "center" });

  doc.end();

  await new Promise((resolve) => writeStream.on("finish", resolve));
  return pdfPath;
};

/**
 * Sinh file JSON metadata
 */
const generateMetadataJSON = async (txHash, meta) => {
  const tmpDir = path.join(__dirname, "../../uploads");
  if (!fs.existsSync(tmpDir)) fs.mkdirSync(tmpDir, { recursive: true });

  const jsonPath = path.join(tmpDir, `metadata_${txHash}.json`);
  fs.writeFileSync(jsonPath, JSON.stringify(meta, null, 2));
  return jsonPath;
};

/**
 * Sinh PDF + JSON ‚Üí upload l√™n IPFS + l∆∞u v√†o DB
 */
const generateAndUploadReceipt = async ({ txHash, owner, meta }) => {
  try {
    // ‚úÖ Ki·ªÉm tra tr√πng txHash
    const existing = await Receipt.findOne({ txHash });
    if (existing) {
      logger.warn("Receipt already exists for txHash", { txHash });
      return {
        cid: existing.cid,
        files: ["receipt.pdf", "receipt.json"],
        urls: [existing.ipfsUrl],
        message: "Receipt already exists for this transaction",
      };
    }

    // 1Ô∏è‚É£ Sinh file PDF & JSON t·∫°m
    const pdfPath = await generateReceiptPDF(txHash, owner, meta);
    const jsonPath = await generateMetadataJSON(txHash, meta);

    // üîπ ƒê·ªçc k√≠ch th∆∞·ªõc file tr∆∞·ªõc khi x√≥a
    const pdfSize = fs.statSync(pdfPath).size;

    // 2Ô∏è‚É£ Upload l√™n Pinata
    const pdfUpload = await uploadToIPFS(pdfPath, `receipt_${txHash}.pdf`);
    const jsonUpload = await uploadToIPFS(jsonPath, `metadata_${txHash}.json`);

    // 3Ô∏è‚É£ L∆∞u v√†o MongoDB khi c√≥ CID th·∫≠t
    const receipt = await Receipt.create({
      txHash,
      owner,
      fileName: `receipt_${txHash}.pdf`,
      cid: pdfUpload.cid,
      fileSize: pdfSize,
      mimeType: "application/pdf",
      status: "PINNED",
      metadata: meta,
    });

    logger.info("‚úÖ Receipt pinned successfully", { cid: receipt.cid });

    // 4Ô∏è‚É£ Tr·∫£ response cho client
    return {
      cid: pdfUpload.cid,
      files: ["receipt.pdf", "receipt.json"],
      urls: [pdfUpload.url, jsonUpload.url],
    };
  } catch (error) {
    logger.error("‚ùå Error in generateAndUploadReceipt", { error: error.message });
    throw error;
  }
};

module.exports = { uploadToIPFS, generateAndUploadReceipt };
