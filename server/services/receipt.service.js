/**
 * Receipt Service
 * Business logic cho IPFS receipts (Pinata version)
 */

const axios = require("axios");
const FormData = require("form-data");
const fs = require("fs");
const path = require("path");
const PDFDocument = require("pdfkit");
const crypto = require("crypto");
const { logger } = require("../adapters/logger.adapter");
const Receipt = require("../models/receipt.model");

// ==== Config / ENV ====
const pinataJWT = process.env.PINATA_JWT;
if (!pinataJWT) throw new Error("Missing PINATA_JWT in environment");

const IPFS_PUBLIC_GATEWAY =
  process.env.IPFS_PUBLIC_GATEWAY || "https://gateway.pinata.cloud/ipfs/";

// ==== Helpers ====
const isValidTxHash = (tx) => /^0x[a-fA-F0-9]{64}$/.test(tx);

// Tạo thư mục tạm uploads nếu chưa tồn tại
const ensureTmpDir = () => {
  const tmpDir = path.join(__dirname, "../../uploads");
  if (!fs.existsSync(tmpDir)) fs.mkdirSync(tmpDir, { recursive: true });
  return tmpDir;
};

// ==== Core IPFS ====
/**
 * Upload file (PDF/JSON) lên IPFS thông qua Pinata
 * @param {string} filePath - đường dẫn file local
 * @param {string} fileName - tên file gợi ý (không bắt buộc với gateway)
 * @returns {{cid: string, url: string}}
 */
const uploadToIPFS = async (filePath, fileName) => {
  try {
    const data = new FormData();
    data.append("file", fs.createReadStream(filePath), fileName || undefined);

    const res = await axios.post(
      "https://api.pinata.cloud/pinning/pinFileToIPFS",
      data,
      {
        maxBodyLength: Infinity,
        timeout: 60_000,
        headers: {
          Authorization: `Bearer ${pinataJWT}`,
          ...data.getHeaders(),
        },
      }
    );

    const cid = res?.data?.IpfsHash;
    const url = `${IPFS_PUBLIC_GATEWAY}${cid}`;
    if (!cid) {
      throw new Error("Pinata response missing IpfsHash");
    }

    logger.info("✅ File uploaded to IPFS via Pinata", { cid, url });
    return { cid, url };
  } catch (error) {
    logger.error("❌ IPFS upload error (Pinata)", {
      error: error?.message,
      code: error?.code,
      status: error?.response?.status,
    });
    throw error;
  } finally {
    // Xoá file tạm sau khi upload
    try {
      if (fs.existsSync(filePath)) fs.unlinkSync(filePath);
    } catch (e) {
      logger.warn("Cannot remove temp file", { filePath, error: e.message });
    }
  }
};

// ==== Receipt generation ====
/**
 * Sinh file PDF biên lai giao dịch
 * @returns {Promise<string>} đường dẫn file PDF tạm
 */
const generateReceiptPDF = async (txHash, owner, meta) => {
  const tmpDir = ensureTmpDir();
  const safeHash = txHash.replace(/[^a-zA-Z0-9]/g, "").slice(0, 20);
  const pdfPath = path.join(tmpDir, `receipt_${safeHash}.pdf`);

  const doc = new PDFDocument({ margin: 50, size: "A5" });
  const writeStream = fs.createWriteStream(pdfPath);
  doc.pipe(writeStream);

  // Header
  doc.fontSize(20).font("Helvetica-Bold").text("SAMPLE RECEIPT", { align: "center" }).moveDown(0.3);
  doc.fontSize(10).font("Helvetica").text("Blockchain Transaction Receipt", { align: "center" }).moveDown(0.5);
  doc.fontSize(8).text("Generated by EVM Multichain Wallet", { align: "center" }).moveDown(1);

  // Separator line
  doc.moveTo(40, doc.y).lineTo(300, doc.y).strokeColor("#000").stroke();

  // Transaction info
  doc.moveDown(0.8);
  doc.fontSize(10).font("Helvetica-Bold").text("TRANSACTION DETAILS");
  doc.moveDown(0.5);
  doc.fontSize(9).font("Helvetica");
  doc.text(`Tx Hash: ${txHash}`, { width: 280 });
  doc.text(`Owner: ${owner}`);
  doc.text(`Date: ${new Date().toLocaleString()}`);
  doc.moveDown(0.3);

  // Metadata block
  doc.moveDown(0.8);
  doc.fontSize(10).font("Helvetica-Bold").text("TRADE DETAILS");
  doc.moveDown(0.3);
  doc.font("Helvetica");
  doc.text(`Pair: ${meta?.pair ?? "N/A"}`);
  doc.text(`Amount In: ${meta?.amountIn ?? "N/A"} ${meta?.symbolIn ?? "ETH"}`);
  doc.text(`Amount Out: ${meta?.amountOut ?? "N/A"} ${meta?.symbolOut ?? "USDT"}`);
  doc.text(`Price: ${meta?.price ?? "N/A"}`);
  if (meta?.chainName) doc.text(`Network: ${meta.chainName}`);
  if (meta?.status) doc.text(`Status: ${meta.status}`);

  // Dashed separator
  const y = doc.y + 8;
  doc.moveTo(40, y).lineTo(300, y).dash(3, { space: 3 }).strokeColor("#555").stroke().undash();

  // Summary
  doc.moveDown(1);
  doc.fontSize(10).font("Helvetica-Bold").text("TOTAL SUMMARY");
  doc.font("Helvetica").fontSize(9);
  doc.text(`Final Amount: ${meta?.amountOut ?? "N/A"} ${meta?.symbolOut ?? "USDT"}`, { align: "left" });
  doc.text(`Network: ${meta?.chainName ?? "Sepolia Testnet"}`, { align: "left" });
  doc.text(`Status: ${meta?.status ?? "✅ Confirmed"}`, { align: "left" });

  // Signature line
  doc.moveDown(2);
  const signatureLineY = doc.y + 10;
  doc.moveTo(60, signatureLineY).lineTo(200, signatureLineY).strokeColor("#000").stroke();
  doc.fontSize(9).text("Authorized Signature", 70, signatureLineY + 5);

  // Footer
  doc.moveDown(2);
  doc.fontSize(8).fillColor("#555").text("Thank you for using EVM Multichain Wallet", { align: "center" });

  doc.end();
  await new Promise((resolve, reject) => {
    writeStream.on("finish", resolve);
    writeStream.on("error", reject);
  });

  return pdfPath;
};

/**
 * Sinh file JSON metadata
 * @returns {Promise<string>} đường dẫn file JSON tạm
 */
const generateMetadataJSON = async (txHash, meta) => {
  const tmpDir = ensureTmpDir();
  const safeHash = txHash.replace(/[^a-zA-Z0-9]/g, "").slice(0, 20);
  const jsonPath = path.join(tmpDir, `metadata_${safeHash}.json`);
  fs.writeFileSync(jsonPath, JSON.stringify(meta ?? {}, null, 2));
  return jsonPath;
};

// ==== Business flows ====
/**
 * Sinh PDF + JSON → upload IPFS → lưu DB (idempotent theo txHash)
 */
const generateAndUploadReceipt = async ({ txHash, owner, meta }) => {
  if (!isValidTxHash(txHash)) throw new Error("Invalid txHash format");
  if (!owner) throw new Error("Missing owner address");

  try {
    // 1) Idempotency: nếu đã có thì trả về luôn
    const existing = await Receipt.findByTxHash(txHash);
    if (existing) {
      logger.warn("Receipt already exists for txHash", { txHash });
      return {
        cid: existing.cid,
        files: ["receipt.pdf", "metadata.json"],
        urls: [existing.ipfsUrl],
        message: "Receipt already exists for this transaction",
      };
    }

    // 2) Sinh file tạm
    const pdfPath = await generateReceiptPDF(txHash, owner, meta);
    const jsonPath = await generateMetadataJSON(txHash, meta);

    // Lấy kích thước PDF (trước khi xoá)
    const pdfSize = fs.statSync(pdfPath).size;

    // 3) Upload lên Pinata
    const pdfUpload = await uploadToIPFS(pdfPath, `receipt_${txHash}.pdf`);
    const jsonUpload = await uploadToIPFS(jsonPath, `metadata_${txHash}.json`);

    // 4) Lưu DB (receipt chính gắn với file PDF)
    const receipt = await Receipt.create({
      txHash,
      owner,
      fileName: `receipt_${txHash}.pdf`,
      cid: pdfUpload.cid,
      fileSize: pdfSize,
      mimeType: "application/pdf",
      status: "PINNED",
      metadata: meta ?? {},
    });

    logger.info("✅ Receipt pinned successfully", { cid: receipt.cid });

    // 5) Trả response
    return {
      cid: pdfUpload.cid,
      files: ["receipt.pdf", "metadata.json"],
      urls: [pdfUpload.url, jsonUpload.url],
    };
  } catch (error) {
    logger.error("❌ Error in generateAndUploadReceipt", { error: error.message });
    throw error;
  }
};

/**
 * Tải file từ IPFS & tính SHA256 để so sánh (best-effort)
 * Vì không giữ file local gốc, ta xác minh tính toàn vẹn của nội dung IPFS
 */
const verifyReceiptIntegrity = async (txHash) => {
  try {
    if (!isValidTxHash(txHash)) {
      return { ok: false, error: "Invalid txHash format" };
    }

    const receipt = await Receipt.findByTxHash(txHash);
    if (!receipt) {
      return { ok: false, error: "Receipt not found" };
    }

    const fileUrl = `${IPFS_PUBLIC_GATEWAY}${receipt.cid}`;
    const res = await axios.get(fileUrl, { responseType: "arraybuffer", timeout: 30_000 });
    const ipfsBuffer = Buffer.from(res.data);
    const ipfsHash = crypto.createHash("sha256").update(ipfsBuffer).digest("hex");

    // Ở đây chỉ đảm bảo tải được và băm thành công (nếu cần có "expectedHash", hãy lưu trong DB/metadata khi sinh file)
    const ok = Boolean(ipfsHash);
    return { ok, sha256: ipfsHash, cid: receipt.cid };
  } catch (error) {
    logger.error("❌ Verify receipt failed", { error: error.message });
    // Để controller trả 500 hoặc 404 phù hợp, ta ném lỗi ra ngoài.
    throw error;
  }
};

/**
 * Chuẩn hoá dữ liệu trả về cho FE, dùng trong controller.getByTxHash
 */
const findByTxHash = async (txHash) => {
  if (!isValidTxHash(txHash)) return null;
  const receipt = await Receipt.findByTxHash(txHash);
  if (!receipt) return null;

  return {
    txHash: receipt.txHash,
    cid: receipt.cid,
    fileName: receipt.fileName,
    ipfsUrl: receipt.ipfsUrl, // virtual từ model
    status: receipt.status,
    createdAt: receipt.createdAt,
  };
};

module.exports = {
  // public methods
  uploadToIPFS,
  generateAndUploadReceipt,
  verifyReceiptIntegrity,
  findByTxHash,

  // exported for unit tests (nếu cần)
  generateReceiptPDF,
  generateMetadataJSON,
};
