/**
 * Receipt Service
 * Business logic cho IPFS receipts (Pinata version)
 */

const axios = require("axios");
const FormData = require("form-data");
const fs = require("fs");
const path = require("path");
const PDFDocument = require("pdfkit");
const crypto = require("crypto");
const { logger } = require("../adapters/logger.adapter");
const Receipt = require("../models/receipt.model");

// ==== Config / ENV ====
const pinataJWT = process.env.PINATA_JWT;
if (!pinataJWT) throw new Error("Missing PINATA_JWT in environment");

const IPFS_PUBLIC_GATEWAY =
  process.env.IPFS_PUBLIC_GATEWAY || "https://gateway.pinata.cloud/ipfs/";

// ==== Helpers ====
const isValidTxHash = (tx) => /^0x[a-fA-F0-9]{64}$/.test(tx);
const isEthAddr = (a) => /^0x[a-fA-F0-9]{40}$/.test(a);

// Tạo thư mục tạm uploads nếu chưa tồn tại
const ensureTmpDir = () => {
  const tmpDir = path.join(__dirname, "../../uploads");
  if (!fs.existsSync(tmpDir)) fs.mkdirSync(tmpDir, { recursive: true });
  return tmpDir;
};

// ==== Core IPFS ====
const uploadToIPFS = async (filePath, fileName) => {
  try {
    const data = new FormData();
    data.append("file", fs.createReadStream(filePath), fileName || undefined);

    const res = await axios.post(
      "https://api.pinata.cloud/pinning/pinFileToIPFS",
      data,
      {
        maxBodyLength: Infinity,
        timeout: 60_000,
        headers: {
          Authorization: `Bearer ${pinataJWT}`,
          ...data.getHeaders(),
        },
      }
    );

    const cid = res?.data?.IpfsHash;
    const url = `${IPFS_PUBLIC_GATEWAY}${cid}`;
    if (!cid) {
      throw new Error("Pinata response missing IpfsHash");
    }

    logger.info("✅ File uploaded to IPFS via Pinata", { cid, url });
    return { cid, url };
  } catch (error) {
    logger.error("❌ IPFS upload error (Pinata)", {
      error: error?.message,
      code: error?.code,
      status: error?.response?.status,
    });
    throw error;
  } finally {
    try {
      if (fs.existsSync(filePath)) fs.unlinkSync(filePath);
    } catch (e) {
      logger.warn("Cannot remove temp file", { filePath, error: e.message });
    }
  }
};

// ==== Receipt generation ====
const generateReceiptPDF = async (txHash, owner, meta) => {
  const tmpDir = ensureTmpDir();
  const safeHash = txHash.replace(/[^a-zA-Z0-9]/g, "").slice(0, 20);
  const pdfPath = path.join(tmpDir, `receipt_${safeHash}.pdf`);

  const doc = new PDFDocument({ margin: 50, size: "A5" });
  const writeStream = fs.createWriteStream(pdfPath);
  doc.pipe(writeStream);

  // Header
  doc.fontSize(20).font("Helvetica-Bold").text("SAMPLE RECEIPT", { align: "center" }).moveDown(0.3);
  doc.fontSize(10).font("Helvetica").text("Blockchain Transaction Receipt", { align: "center" }).moveDown(0.5);
  doc.fontSize(8).text("Generated by EVM Multichain Wallet", { align: "center" }).moveDown(1);

  // Separator line
  doc.moveTo(40, doc.y).lineTo(300, doc.y).strokeColor("#000").stroke();

  // Transaction info
  doc.moveDown(0.8);
  doc.fontSize(10).font("Helvetica-Bold").text("TRANSACTION DETAILS");
  doc.moveDown(0.5);
  doc.fontSize(9).font("Helvetica");
  doc.text(`Tx Hash: ${txHash}`, { width: 280 });
  doc.text(`Owner: ${owner}`);
  doc.text(`Date: ${new Date().toLocaleString()}`);
  doc.moveDown(0.3);

  // Metadata block
  doc.moveDown(0.8);
  doc.fontSize(10).font("Helvetica-Bold").text("TRADE DETAILS");
  doc.moveDown(0.3);
  doc.font("Helvetica");
  doc.text(`Pair: ${meta?.pair ?? "N/A"}`);
  doc.text(`Amount In: ${meta?.amountIn ?? "N/A"} ${meta?.symbolIn ?? "ETH"}`);
  doc.text(`Amount Out: ${meta?.amountOut ?? "N/A"} ${meta?.symbolOut ?? "USDT"}`);
  doc.text(`Price: ${meta?.price ?? "N/A"}`);
  if (meta?.chainName) doc.text(`Network: ${meta.chainName}`);
  if (meta?.status) doc.text(`Status: ${meta.status}`);

  // Dashed separator
  const y = doc.y + 8;
  doc.moveTo(40, y).lineTo(300, y).dash(3, { space: 3 }).strokeColor("#555").stroke().undash();

  // Summary
  doc.moveDown(1);
  doc.fontSize(10).font("Helvetica-Bold").text("TOTAL SUMMARY");
  doc.font("Helvetica").fontSize(9);
  doc.text(`Final Amount: ${meta?.amountOut ?? "N/A"} ${meta?.symbolOut ?? "USDT"}`, { align: "left" });
  doc.text(`Network: ${meta?.chainName ?? "Sepolia Testnet"}`, { align: "left" });
  doc.text(`Status: ${meta?.status ?? "✅ Confirmed"}`, { align: "left" });

  // Signature line
  doc.moveDown(2);
  const signatureLineY = doc.y + 10;
  doc.moveTo(60, signatureLineY).lineTo(200, signatureLineY).strokeColor("#000").stroke();
  doc.fontSize(9).text("Authorized Signature", 70, signatureLineY + 5);

  // Footer
  doc.moveDown(2);
  doc.fontSize(8).fillColor("#555").text("Thank you for using EVM Multichain Wallet", { align: "center" });

  doc.end();
  await new Promise((resolve, reject) => {
    writeStream.on("finish", resolve);
    writeStream.on("error", reject);
  });

  return pdfPath;
};

const generateMetadataJSON = async (txHash, meta) => {
  const tmpDir = ensureTmpDir();
  const safeHash = txHash.replace(/[^a-zA-Z0-9]/g, "").slice(0, 20);
  const jsonPath = path.join(tmpDir, `metadata_${safeHash}.json`);
  fs.writeFileSync(jsonPath, JSON.stringify(meta ?? {}, null, 2));
  return jsonPath;
};

// ==== Business flows ====
const generateAndUploadReceipt = async ({ txHash, owner, meta }) => {
  if (!isValidTxHash(txHash)) throw new Error("Invalid txHash format");
  if (!owner || !isEthAddr(owner)) throw new Error("Invalid owner address");

  try {
    const existing = await Receipt.findByTxHash(txHash);
    if (existing) {
      logger.warn("Receipt already exists for txHash", { txHash });
      return {
        cid: existing.cid,
        files: ["receipt.pdf", "metadata.json"],
        urls: [existing.ipfsUrl],
        message: "Receipt already exists for this transaction",
      };
    }

    const pdfPath = await generateReceiptPDF(txHash, owner, meta);
    const jsonPath = await generateMetadataJSON(txHash, meta);
    const pdfSize = fs.statSync(pdfPath).size;

    const pdfUpload = await uploadToIPFS(pdfPath, `receipt_${txHash}.pdf`);
    const jsonUpload = await uploadToIPFS(jsonPath, `metadata_${txHash}.json`);

    const receipt = await Receipt.create({
      txHash,
      owner: owner.toLowerCase(),
      fileName: `receipt_${txHash}.pdf`,
      cid: pdfUpload.cid,
      fileSize: pdfSize,
      mimeType: "application/pdf",
      status: "PINNED",
      metadata: meta ?? {},
    });

    logger.info("✅ Receipt pinned successfully", { cid: receipt.cid });

    return {
      cid: pdfUpload.cid,
      files: ["receipt.pdf", "metadata.json"],
      urls: [pdfUpload.url, jsonUpload.url],
    };
  } catch (error) {
    logger.error("❌ Error in generateAndUploadReceipt", { error: error.message });
    throw error;
  }
};

const verifyReceiptIntegrity = async (txHash) => {
  try {
    if (!isValidTxHash(txHash)) {
      return { ok: false, error: "Invalid txHash format" };
    }

    const receipt = await Receipt.findByTxHash(txHash);
    if (!receipt) {
      return { ok: false, error: "Receipt not found" };
    }

    const fileUrl = `${IPFS_PUBLIC_GATEWAY}${receipt.cid}`;
    const res = await axios.get(fileUrl, { responseType: "arraybuffer", timeout: 30_000 });
    const ipfsBuffer = Buffer.from(res.data);
    const ipfsHash = crypto.createHash("sha256").update(ipfsBuffer).digest("hex");

    const ok = Boolean(ipfsHash);
    return { ok, sha256: ipfsHash, cid: receipt.cid };
  } catch (error) {
    logger.error("❌ Verify receipt failed", { error: error.message });
    throw error;
  }
};

const findByTxHash = async (txHash) => {
  if (!isValidTxHash(txHash)) return null;
  const receipt = await Receipt.findByTxHash(txHash);
  if (!receipt) return null;

  return {
    txHash: receipt.txHash,
    cid: receipt.cid,
    fileName: receipt.fileName,
    ipfsUrl: receipt.ipfsUrl,
    status: receipt.status,
    createdAt: receipt.createdAt,
  };
};

/** ✅ NEW: Liệt kê receipts theo user + phân trang (sort createdAt desc) */
const listByUser = async (ownerAddress, { page = 1, pageSize = 20 } = {}) => {
  if (!ownerAddress || !isEthAddr(ownerAddress)) {
    throw new Error("Invalid owner address");
  }
  const owner = ownerAddress.toLowerCase();
  const skip = (page - 1) * pageSize;

  const [total, docs] = await Promise.all([
    Receipt.countDocuments({ owner }),
    Receipt.find({ owner }).sort({ createdAt: -1 }).skip(skip).limit(pageSize),
  ]);

  const items = docs.map((r) => ({
    txHash: r.txHash,
    cid: r.cid,
    fileName: r.fileName,
    ipfsUrl: r.ipfsUrl,
    status: r.status,
    createdAt: r.createdAt,
  }));

  return { items, total };
};

/** ✅ NEW: Build URL tải file theo txHash + type (hiện hỗ trợ pdf) */
const getDownloadUrl = async (txHash, { type = "pdf" } = {}) => {
  if (!isValidTxHash(txHash)) throw new Error("Invalid txHash format");

  const rec = await Receipt.findByTxHash(txHash);
  if (!rec) return { url: null };

  // Hiện chỉ lưu CID PDF trong record => chỉ hỗ trợ type=pdf
  if (type !== "pdf") {
    // Nếu sau này lưu thêm jsonCid trong model, map type='json' -> jsonCid ở đây
    return { url: null };
  }

  const url = `${IPFS_PUBLIC_GATEWAY}${rec.cid}`;
  return { url, fileName: rec.fileName || `receipt_${txHash}.pdf` };
};

module.exports = {
  // public methods
  uploadToIPFS,
  generateAndUploadReceipt,
  verifyReceiptIntegrity,
  findByTxHash,
  listByUser,
  getDownloadUrl,          // ✅ export mới cho yêu cầu 5

  // for tests
  generateReceiptPDF,
  generateMetadataJSON,
};
